/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

//@formatter:off
#pragma GCC optimize("Ofast")
#include <bits/stdc++.h>
using namespace std;

//@formatter:off
#define rep(i, n) for (int i = 0; i < (n); ++i)
#define drep(i, n) for (int i = (n)-1; i >= 0; --i)
#define srep(i, s, t) for (int i = s; i < t; ++i)
#define rng(a) a.begin(), a.end()
#define rrng(a) a.rbegin(), a.rend()
using ll = long long;
using P = pair<ll, ll>;
using VI = vector<int>;
using VVI = vector<VI>;
using VVVI = vector<VVI>;
using VVVVI = vector<VVVI>;
using VL = vector<ll>;
using VVL = vector<VL>;
using VVVL = vector<VVL>;
using VVVVL = vector<VVVL>;
using VP = vector<P>;
using VVP = vector<vector<P>>;
using VS = vector<string>;
using VC = vector<char>;
using VVC = vector<vector<char>>;
using VD = vector<double>;
using VVD = vector<vector<double>>;
using VVVD = vector<VVD>;
using I_I = pair<int, int>;
const int INF = (int)1e9 + 10;         // int max > 2*10^9
const long long INFL = (ll)2e18 + 10;  // ll max > 9*10^18

const int JU_5 = 100000;
const int JU_6 = 1000000;
const ll JU_9 = 1000000000;
const ll JU_18 = JU_9*JU_9;


#define YES cout << "YES" << endl
#define NO cout << "NO" << endl
#define Yes cout << "Yes" << endl
#define No cout << "No" << endl

template <typename T, typename C>
pair<T,C> operator+(const pair<T,C> &a, const pair<T,C> &b) { return make_pair(a.first + b.first, a.second + b.second); }
template <typename T, typename C>
pair<T,C> operator-(const pair<T,C> &a, const pair<T,C> &b) { return make_pair(a.first - b.first, a.second - b.second); }
template <typename T, typename C>
pair<T,C> operator*(const pair<T,C> &a, const pair<T,C> &b) { return make_pair(a.first * b.first, a.second * b.second); }
template <typename T, typename C>
pair<T,C> operator/(const pair<T,C> &a, const pair<T,C> &b) { return make_pair(a.first / b.first, a.second / b.second); }


// #define MOD 1000000007
#define MOD 998244353

#define pmod(x,y) ((x%y)+y)%y

/********** libs **********/
//@formatter:off
// jhelper 用変数
ostream *__cout;
istream *__cin;

void _init_io(std::istream &cin, std::ostream &cout) {
    // 入出力高速化用
    ios::sync_with_stdio(false); cin.tie(nullptr);
    cout << std::setprecision(30);
    // jhelper 用
    __cout = &cout; __cin = &cin;
}

//@formatter:off
/* デバッグ用 出力 */
template<typename T>
ostream &operator<<(ostream &os, const deque<T> &vec) { os << "deq["; for (auto v: vec) os << v << ","; os << "]"; return os; }

template<typename T>
ostream &operator<<(ostream &os, const set<T> &vec) { os << "{"; for (auto v: vec) os << v << ","; os << "}"; return os; }

template<typename T>
ostream &operator<<(ostream &os, const unordered_set<T> &vec) { os << "{"; for (auto v: vec) os << v << ","; os << "}"; return os; }

template<typename T>
ostream &operator<<(ostream &os, const multiset<T> &vec) { os << "{"; for (auto v: vec) os << v << ","; os << "}"; return os; }

template<typename T>
ostream &operator<<(ostream &os, const unordered_multiset<T> &vec) { os << "{"; for (auto v: vec) os << v << ","; os << "}"; return os; }

template<typename T1, typename T2>
ostream &operator<<(ostream &os, const pair<T1, T2> &pa) { os << "(" << pa.first << "," << pa.second << ")"; return os; }
template<typename TK, typename TV>
ostream &operator<<(ostream &os, const map<TK, TV> &mp) { os << "{"; for (auto v: mp) os << v.first << "=>" << v.second << ","; os << "}"; return os; }

template<typename TK, typename TV>
ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp) { os << "{"; for (auto v: mp) os << v.first << "=>" << v.second << ","; os << "}"; return os; }

// print like python
// src: https://qiita.com/Lily0727K/items/06cb1d6da8a436369eed
/////////////////////////////////////////////////////////
void print() { *__cout << '\n'; }
template<class Head, class... Tail>
void print(Head &&head, Tail &&... tail) { *__cout << head; if (sizeof...(tail) != 0) *__cout << " "; print(forward<Tail>(tail)...); }
template<class T>
void print(vector<T> &vec) { for (auto &a: vec) { *__cout << a; if (&a != &vec.back()) *__cout << " "; } *__cout << '\n'; }
template<class T>
void print(vector<vector<T>> &df) { for (auto &vec: df) { print(vec); } }

// endl なし
void Print() {}
template<class Head, class... Tail>
void Print(Head &&head, Tail &&... tail) { *__cout << head; if (sizeof...(tail) != 0) *__cout << " "; Print(forward<Tail>(tail)...); }
template<class T>
void Print(vector<T> &vec) { for (auto &a: vec) { *__cout << a; if (&a != &vec.back()) *__cout << " "; } }
//@formatter:off
/*
 * org: https://atcoder.jp/contests/abc213/submissions/24901856
 * jhelper で使用するため, 全部 cin での入力にしている. (現状のレベルでは困らないので)
 */
template<class T> void scan(T& a){ *__cin >> a; }
template<class T> void scan(vector<T>&);
template<class T, class L> void scan(pair<T, L>&);
template<class T> void scan(vector<T>& a){ for(auto&& i : a) scan(i); }
template<class T, class L> void scan(pair<T, L>& p){ scan(p.first); scan(p.second); }
template<class T, size_t size> void scan(T (&a)[size]){ for(auto&& i : a) scan(i); }
void in(){}
template <class... T> void in(T&... a){ (void)initializer_list<int>{ (scan(a), 0)... }; }

#define let_v(type,name,...) vector<type>name(__VA_ARGS__)
#define let_V(type,name,size) vector<type>name(size);in(name)
#define let_vv(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))
#define let_VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));in(name)
#define let_vvv(type,name,h,w,...) vector<vector<vector<type>>>name(h,vector<vector<type>>(w,vector<type>(__VA_ARGS__)))
#define let_vvvv(type,name,h,w,x,...) vector<vector<vector<vector<type>>>>name(h,vector<vector<vector<type>>>(w,vector<vector<type>>(x,vector<type>(__VA_ARGS__))))

/* string 入力を vector<char> で受け取るみたいな */
vector<char> let_CharVec() { string s; *__cin >> s; return {s.begin(), s.end()}; }

//@formatter:off
//ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }
ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }

template <class T, class C>
bool chmax(T& a, C b) { if (a < b) { a = b; return true; } return false; }
template <class T, class C>
bool chmin(T& a, C b) { if (a > b) { a = b; return true; } return false; }

template <class T>
T sum(const vector<T>& v) { T res = 0; for (size_t i = 0; i < v.size(); ++i) res += v[i]; return res; }

template <class T, class C>
T min(T a, C b) { return a <= b ? a : T(b); }

template <class T, class C>
T max(T a, C b) { return a >= b ? a : T(b); }

template<class T>
vector<pair<T, int>> idx_pair(vector<T> &vals) { vector<pair<T, int>> ans; rep(i, vals.size()) { ans.emplace_back(vals[i], i); } return ans; }

/* ids 順に並び替え */
template<typename T>
vector<T> sort_with_ids(vector<T> &vals,vector<int> &ids){ vector<T> res; for(int i = 0;i<vals.size();i++){ res.push_back(vals[ids[i]]); } return res; }

template<typename T>
int argmax(vector<T> &vals){ if(vals.size()==0)return -1; int res=0; for(int i = 1;i<vals.size();i++){ if(vals[i]>vals[res])res=i; } return res; }

template<typename T>
int argmin(vector<T> &vals){ if(vals.size()==0)return -1; int res=0; for(int i = 1;i<vals.size();i++){ if(vals[i]<vals[res])res=i; } return res; }


// add other source
// #include "../library/graph/UnionFind.cpp"
// #include "../library/tree/SegmentTree.cpp"
// #include "../library/others/Zaatsu.cpp"
// #include "../library/graph/template.cpp"

// utils
// #include "../library/mint.cpp"
// #include "../library/string/utils.cpp"
// #include "../library/math/utils.cpp"
/**************************/

class DNotDivisible {
public:
void solve(std::istream &cin, std::ostream &cout) { _init_io(cin, cout); int t = 1;
//    cin >> t;
    while (t--) _solve(cin, cout); }
//@formatter:on

    void _solve(std::istream &cin, std::ostream &cout) {
        // code
        int n;
        cin >> n;
        let_V(ll, a, n);
        sort(rng(a));
        VI arr(JU_6 + 10, 0);
        srep(i,0, n-1) {
            if(a[i]==a[i+1])arr[a[i]]=1;
        }
        a.erase(unique(rng(a)), a.end());
        int cnt = 0;

        rep(i, a.size()) {
            if (!arr[a[i]])cnt++;
            ll v = a[i];
            while (v <= JU_6) {
                arr[v]++;
                v += a[i];
            }
        }
        print(cnt);
    }

};


int main() {
	DNotDivisible solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
